import { __decorate } from "tslib";
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';
import { NgxCSVParserError } from './_model/ngx-csv-parser-error.interface';
import * as i0 from "@angular/core";
let NgxCsvParser = class NgxCsvParser {
    constructor() {
        this.defaultCSVParserConfig = {
            header: true,
            delimiter: ','
        };
        console.log(`
      *****************************************************
      ***      For Custom Software/Web development      ***
      *** Reach out to us at contact@developershive.com ***
      ***     Visit us at https://developershive.com    ***
      *****************************************************
    `);
    }
    parse(csvFile, config) {
        config = Object.assign(Object.assign({}, this.defaultCSVParserConfig), config);
        const ngxCSVParserObserver = Observable.create((observer) => {
            try {
                let csvRecords = null;
                if (this.isCSVFile(csvFile)) {
                    const reader = new FileReader();
                    reader.readAsText(csvFile);
                    reader.onload = () => {
                        const csvData = reader.result;
                        const csvRecordsArray = csvData.trim().split(/\r\n|\n/);
                        const headersRow = this.getHeaderArray(csvRecordsArray, config);
                        csvRecords = this.getDataRecordsArrayFromCSVFile(csvRecordsArray, headersRow.length, config);
                        observer.next(csvRecords);
                        observer.complete();
                    };
                    reader.onerror = () => {
                        this.badCSVDataFormatErrorHandler(observer);
                    };
                }
                else {
                    this.notCSVFileErrorHandler(observer);
                }
            }
            catch (error) {
                this.unknownCSVParserErrorHandler(observer);
            }
        });
        return ngxCSVParserObserver;
    }
    getDataRecordsArrayFromCSVFile(csvRecordsArray, headerLength, config) {
        const dataArr = [];
        const headersArray = csvRecordsArray[0].split(config.delimiter);
        const startingRowToParseData = config.header ? 1 : 0;
        for (let i = startingRowToParseData; i < csvRecordsArray.length; i++) {
            const data = csvRecordsArray[i].split(config.delimiter);
            if (data.length === headerLength && config.header) {
                const csvRecord = {};
                for (let j = 0; j < data.length; j++) {
                    csvRecord[headersArray[j]] = data[j].trim();
                }
                dataArr.push(csvRecord);
            }
            else {
                dataArr.push(data);
            }
        }
        return dataArr;
    }
    isCSVFile(file) {
        return file.name.endsWith('.csv');
    }
    getHeaderArray(csvRecordsArr, config) {
        const headers = csvRecordsArr[0].split(config.delimiter);
        const headerArray = [];
        for (const header of headers) {
            headerArray.push(header);
        }
        return headerArray;
    }
    notCSVFileErrorHandler(observer) {
        const ngcCSVParserError = new NgxCSVParserError();
        ngcCSVParserError.type = 'NOT_A_CSV_FILE';
        ngcCSVParserError.message = 'Selected file is not a csv File Type';
        ngcCSVParserError.code = 2;
        observer.error(ngcCSVParserError);
    }
    unknownCSVParserErrorHandler(observer) {
        const ngcCSVParserError = new NgxCSVParserError();
        ngcCSVParserError.type = 'UNKNOWN_ERROR';
        ngcCSVParserError.message = 'Unknown error. Please refer to official documentation for library usage.';
        ngcCSVParserError.code = 404;
        observer.error(ngcCSVParserError);
    }
    badCSVDataFormatErrorHandler(observer) {
        const ngcCSVParserError = new NgxCSVParserError();
        ngcCSVParserError.type = 'BAD_CSV_DATA_FORMAT';
        ngcCSVParserError.message = 'Unable to parse CSV File';
        ngcCSVParserError.code = 1;
        observer.error(ngcCSVParserError);
    }
};
NgxCsvParser.ɵprov = i0.ɵɵdefineInjectable({ factory: function NgxCsvParser_Factory() { return new NgxCsvParser(); }, token: NgxCsvParser, providedIn: "root" });
NgxCsvParser = __decorate([
    Injectable({
        providedIn: 'root'
    })
], NgxCsvParser);
export { NgxCsvParser };
class CSVParserConfig {
    constructor() { }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWNzdi1wYXJzZXIuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25neC1jc3YtcGFyc2VyLyIsInNvdXJjZXMiOlsibGliL25neC1jc3YtcGFyc2VyLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFFLFVBQVUsRUFBWSxNQUFNLE1BQU0sQ0FBQztBQUM1QyxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSx5Q0FBeUMsQ0FBQzs7QUFLNUUsSUFBYSxZQUFZLEdBQXpCLE1BQWEsWUFBWTtJQUV2QjtRQVVRLDJCQUFzQixHQUFHO1lBQy9CLE1BQU0sRUFBRSxJQUFJO1lBQ1osU0FBUyxFQUFFLEdBQUc7U0FDZixDQUFDO1FBWkEsT0FBTyxDQUFDLEdBQUcsQ0FBQzs7Ozs7O0tBTVgsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQU9ELEtBQUssQ0FBQyxPQUFhLEVBQUUsTUFBdUI7UUFFMUMsTUFBTSxtQ0FDRCxJQUFJLENBQUMsc0JBQXNCLEdBQzNCLE1BQU0sQ0FDVixDQUFDO1FBRUYsTUFBTSxvQkFBb0IsR0FBRyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsUUFBa0QsRUFBRSxFQUFFO1lBQ3BHLElBQUk7Z0JBRUYsSUFBSSxVQUFVLEdBQUcsSUFBSSxDQUFDO2dCQUV0QixJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLEVBQUU7b0JBRTNCLE1BQU0sTUFBTSxHQUFHLElBQUksVUFBVSxFQUFFLENBQUM7b0JBQ2hDLE1BQU0sQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUM7b0JBRTNCLE1BQU0sQ0FBQyxNQUFNLEdBQUcsR0FBRyxFQUFFO3dCQUNuQixNQUFNLE9BQU8sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO3dCQUM5QixNQUFNLGVBQWUsR0FBSSxPQUFrQixDQUFDLElBQUksRUFBRSxDQUFDLEtBQUssQ0FBQyxT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QUM7UUFDMUMsaUJBQWlCLENBQUMsT0FBTyxHQUFHLHNDQUFzQyxDQUFDO1FBQ25FLGlCQUFpQixDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7UUFDM0IsUUFBUSxDQUFDLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0lBQ3BDLENBQUM7SUFFRCw0QkFBNEIsQ0FBQyxRQUF1QjtRQUNsRCxNQUFNLGlCQUFpQixHQUFzQixJQUFJLGlCQUFpQixFQUFFLENBQUM7UUFDckUsaUJBQWlCLENBQUMsSUFBSSxHQUFHLGVBQWUsQ0FBQztRQUN6QyxpQkFBaUIsQ0FBQyxPQUFPLEdBQUcsMEVBQTBFLENBQUM7UUFDdkcsaUJBQWlCLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQztRQUM3QixRQUFRLENBQUMsS0FBSyxDQUFDLGlCQUFpQixDQUFDLENBQUM7SUFDcEMsQ0FBQztJQUVELDRCQUE0QixDQUFDLFFBQXVCO1FBQ2xELE1BQU0saUJBQWlCLEdBQXNCLElBQUksaUJBQWlCLEVBQUUsQ0FBQztRQUNyRSxpQkFBaUIsQ0FBQyxJQUFJLEdBQUcscUJBQXFCLENBQUM7UUFDL0MsaUJBQWlCLENBQUMsT0FBTyxHQUFHLDBCQUEwQixDQUFDO1FBQ3ZELGlCQUFpQixDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7UUFDM0IsUUFBUSxDQUFDLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0lBQ3BDLENBQUM7Q0FDRixDQUFBOztBQTFIWSxZQUFZO0lBSHhCLFVBQVUsQ0FBQztRQUNWLFVBQVUsRUFBRSxNQUFNO0tBQ25CLENBQUM7R0FDVyxZQUFZLENBMEh4QjtTQTFIWSxZQUFZO0FBNEh6QixNQUFNLGVBQWU7SUFJbkIsZ0JBQWdCLENBQUM7Q0FDbEIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUsIE9ic2VydmVyIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IE5neENTVlBhcnNlckVycm9yIH0gZnJvbSAnLi9fbW9kZWwvbmd4LWNzdi1wYXJzZXItZXJyb3IuaW50ZXJmYWNlJztcclxuXHJcbkBJbmplY3RhYmxlKHtcclxuICBwcm92aWRlZEluOiAncm9vdCdcclxufSlcclxuZXhwb3J0IGNsYXNzIE5neENzdlBhcnNlciB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkgeyBcclxuICAgIGNvbnNvbGUubG9nKGBcclxuICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICAgICAgKioqICAgICAgRm9yIEN1c3RvbSBTb2Z0d2FyZS9XZWIgZGV2ZWxvcG1lbnQgICAgICAqKipcclxuICAgICAgKioqIFJlYWNoIG91dCB0byB1cyBhdCBjb250YWN0QGRldmVsb3BlcnNoaXZlLmNvbSAqKipcclxuICAgICAgKioqICAgICBWaXNpdCB1cyBhdCBodHRwczovL2RldmVsb3BlcnNoaXZlLmNvbSAgICAqKipcclxuICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICAgIGApOyAgICBcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZGVmYXVsdENTVlBhcnNlckNvbmZpZyA9IHtcclxuICAgIGhlYWRlcjogdHJ1ZSxcclxuICAgIGRlbGltaXRlcjogJywnXHJcbiAgfTtcclxuXHJcbiAgcGFyc2UoY3N2RmlsZTogRmlsZSwgY29uZmlnOiBDU1ZQYXJzZXJDb25maWcpOiBPYnNlcnZhYmxlPEFycmF5PGFueT4+IHtcclxuXHJcbiAgICBjb25maWcgPSB7XHJcbiAgICAgIC4uLnRoaXMuZGVmYXVsdENTVlBhcnNlckNvbmZpZyxcclxuICAgICAgLi4uY29uZmlnXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IG5neENTVlBhcnNlck9ic2VydmVyID0gT2JzZXJ2YWJsZS5jcmVhdGUoKG9ic2VydmVyOiBPYnNlcnZlcjxBcnJheTxhbnk+IHwgTmd4Q1NWUGFyc2VyRXJyb3I+KSA9PiB7XHJcbiAgICAgIHRyeSB7XHJcblxyXG4gICAgICAgIGxldCBjc3ZSZWNvcmRzID0gbnVsbDtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuaXNDU1ZGaWxlKGNzdkZpbGUpKSB7XHJcblxyXG4gICAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuICAgICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGNzdkZpbGUpO1xyXG5cclxuICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNzdkRhdGEgPSByZWFkZXIucmVzdWx0O1xyXG4gICAgICAgICAgICBjb25zdCBjc3ZSZWNvcmRzQXJyYXkgPSAoY3N2RGF0YSBhcyBzdHJpbmcpLnRyaW0oKS5zcGxpdCgvXFxyXFxufFxcbi8pO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgaGVhZGVyc1JvdyA9IHRoaXMuZ2V0SGVhZGVyQXJyYXkoY3N2UmVjb3Jkc0FycmF5LCBjb25maWcpO1xyXG5cclxuICAgICAgICAgICAgY3N2UmVjb3JkcyA9IHRoaXMuZ2V0RGF0YVJlY29yZHNBcnJheUZyb21DU1ZGaWxlKGNzdlJlY29yZHNBcnJheSwgaGVhZGVyc1Jvdy5sZW5ndGgsIGNvbmZpZyk7XHJcblxyXG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KGNzdlJlY29yZHMpO1xyXG4gICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICByZWFkZXIub25lcnJvciA9ICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5iYWRDU1ZEYXRhRm9ybWF0RXJyb3JIYW5kbGVyKG9ic2VydmVyKTtcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLm5vdENTVkZpbGVFcnJvckhhbmRsZXIob2JzZXJ2ZXIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgdGhpcy51bmtub3duQ1NWUGFyc2VyRXJyb3JIYW5kbGVyKG9ic2VydmVyKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIG5neENTVlBhcnNlck9ic2VydmVyO1xyXG4gIH1cclxuXHJcbiAgZ2V0RGF0YVJlY29yZHNBcnJheUZyb21DU1ZGaWxlKGNzdlJlY29yZHNBcnJheTogYW55LCBoZWFkZXJMZW5ndGg6IGFueSwgY29uZmlnOiBhbnkpIHtcclxuICAgIGNvbnN0IGRhdGFBcnIgPSBbXTtcclxuICAgIGNvbnN0IGhlYWRlcnNBcnJheSA9IChjc3ZSZWNvcmRzQXJyYXlbMF0gYXMgc3RyaW5nKS5zcGxpdChjb25maWcuZGVsaW1pdGVyKTtcclxuXHJcbiAgICBjb25zdCBzdGFydGluZ1Jvd1RvUGFyc2VEYXRhID0gY29uZmlnLmhlYWRlciA/IDEgOiAwO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSBzdGFydGluZ1Jvd1RvUGFyc2VEYXRhOyBpIDwgY3N2UmVjb3Jkc0FycmF5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSAoY3N2UmVjb3Jkc0FycmF5W2ldIGFzIHN0cmluZykuc3BsaXQoY29uZmlnLmRlbGltaXRlcik7XHJcblxyXG4gICAgICBpZiAoZGF0YS5sZW5ndGggPT09IGhlYWRlckxlbmd0aCAmJiBjb25maWcuaGVhZGVyKSB7XHJcblxyXG4gICAgICAgIGNvbnN0IGNzdlJlY29yZCA9IHt9O1xyXG5cclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGRhdGEubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgIGNzdlJlY29yZFtoZWFkZXJzQXJyYXlbal1dID0gZGF0YVtqXS50cmltKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRhdGFBcnIucHVzaChjc3ZSZWNvcmQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRhdGFBcnIucHVzaChkYXRhKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRhdGFBcnI7XHJcbiAgfVxyXG5cclxuICBpc0NTVkZpbGUoZmlsZTogYW55KSB7XHJcbiAgICByZXR1cm4gZmlsZS5uYW1lLmVuZHNXaXRoKCcuY3N2Jyk7XHJcbiAgfVxyXG5cclxuICBnZXRIZWFkZXJBcnJheShjc3ZSZWNvcmRzQXJyOiBhbnksIGNvbmZpZzogYW55KSB7XHJcbiAgICBjb25zdCBoZWFkZXJzID0gKGNzdlJlY29yZHNBcnJbMF0gYXMgc3RyaW5nKS5zcGxpdChjb25maWcuZGVsaW1pdGVyKTtcclxuICAgIGNvbnN0IGhlYWRlckFycmF5ID0gW107XHJcbiAgICBmb3IgKGNvbnN0IGhlYWRlciBvZiBoZWFkZXJzKSB7XHJcbiAgICAgIGhlYWRlckFycmF5LnB1c2goaGVhZGVyKTtcclxuICAgIH1cclxuICAgIHJldHVybiBoZWFkZXJBcnJheTtcclxuICB9XHJcblxyXG4gIG5vdENTVkZpbGVFcnJvckhhbmRsZXIob2JzZXJ2ZXI6IE9ic2VydmVyPGFueT4pIHtcclxuICAgIGNvbnN0IG5nY0NTVlBhcnNlckVycm9yOiBOZ3hDU1ZQYXJzZXJFcnJvciA9IG5ldyBOZ3hDU1ZQYXJzZXJFcnJvcigpO1xyXG4gICAgbmdjQ1NWUGFyc2VyRXJyb3IudHlwZSA9ICdOT1RfQV9DU1ZfRklMRSc7XHJcbiAgICBuZ2NDU1ZQYXJzZXJFcnJvci5tZXNzYWdlID0gJ1NlbGVjdGVkIGZpbGUgaXMgbm90IGEgY3N2IEZpbGUgVHlwZSc7XHJcbiAgICBuZ2NDU1ZQYXJzZXJFcnJvci5jb2RlID0gMjtcclxuICAgIG9ic2VydmVyLmVycm9yKG5nY0NTVlBhcnNlckVycm9yKTtcclxuICB9XHJcblxyXG4gIHVua25vd25DU1ZQYXJzZXJFcnJvckhhbmRsZXIob2JzZXJ2ZXI6IE9ic2VydmVyPGFueT4pIHtcclxuICAgIGNvbnN0IG5nY0NTVlBhcnNlckVycm9yOiBOZ3hDU1ZQYXJzZXJFcnJvciA9IG5ldyBOZ3hDU1ZQYXJzZXJFcnJvcigpO1xyXG4gICAgbmdjQ1NWUGFyc2VyRXJyb3IudHlwZSA9ICdVTktOT1dOX0VSUk9SJztcclxuICAgIG5nY0NTVlBhcnNlckVycm9yLm1lc3NhZ2UgPSAnVW5rbm93biBlcnJvci4gUGxlYXNlIHJlZmVyIHRvIG9mZmljaWFsIGRvY3VtZW50YXRpb24gZm9yIGxpYnJhcnkgdXNhZ2UuJztcclxuICAgIG5nY0NTVlBhcnNlckVycm9yLmNvZGUgPSA0MDQ7XHJcbiAgICBvYnNlcnZlci5lcnJvcihuZ2NDU1ZQYXJzZXJFcnJvcik7XHJcbiAgfVxyXG5cclxuICBiYWRDU1ZEYXRhRm9ybWF0RXJyb3JIYW5kbGVyKG9ic2VydmVyOiBPYnNlcnZlcjxhbnk+KSB7XHJcbiAgICBjb25zdCBuZ2NDU1ZQYXJzZXJFcnJvcjogTmd4Q1NWUGFyc2VyRXJyb3IgPSBuZXcgTmd4Q1NWUGFyc2VyRXJyb3IoKTtcclxuICAgIG5nY0NTVlBhcnNlckVycm9yLnR5cGUgPSAnQkFEX0NTVl9EQVRBX0ZPUk1BVCc7XHJcbiAgICBuZ2NDU1ZQYXJzZXJFcnJvci5tZXNzYWdlID0gJ1VuYWJsZSB0byBwYXJzZSBDU1YgRmlsZSc7XHJcbiAgICBuZ2NDU1ZQYXJzZXJFcnJvci5jb2RlID0gMTtcclxuICAgIG9ic2VydmVyLmVycm9yKG5nY0NTVlBhcnNlckVycm9yKTtcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIENTVlBhcnNlckNvbmZpZyB7XHJcbiAgaGVhZGVyPzogYm9vbGVhbjtcclxuICBkZWxpbWl0ZXI/OiBzdHJpbmc7XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkgeyB9XHJcbn1cclxuIl19